var documenterSearchIndex = {"docs":
[{"location":"parameters/conversions/#Parameter-Conversions","page":"Parameter Conversions","title":"Parameter Conversions","text":"","category":"section"},{"location":"parameters/conversions/","page":"Parameter Conversions","title":"Parameter Conversions","text":"This page is under construction, thank you for your patience.","category":"page"},{"location":"parameters/conversions/","page":"Parameter Conversions","title":"Parameter Conversions","text":"We provide helper functions to convert between various parameters commonly used to describe the observing conditions.","category":"page"},{"location":"parameters/conversions/#Helper-Functions","page":"Parameter Conversions","title":"Helper Functions","text":"","category":"section"},{"location":"parameters/conversions/","page":"Parameter Conversions","title":"Parameter Conversions","text":"Kolmogorov.Cn_squared_to_fried\nKolmogorov.fried_to_Cn_squared\nKolmogorov.fried_to_seeing\nKolmogorov.seeing_to_fried","category":"page"},{"location":"parameters/conversions/#Kolmogorov.Cn_squared_to_fried","page":"Parameter Conversions","title":"Kolmogorov.Cn_squared_to_fried","text":"Cn_squared_to_fried(Cn_squared::AbstractFloat,\n                    wavelength::AbstractFloat=500e-9)\n\nCalculates the Fried parameter (r_0) from a provided C_n^2 value and (optionally) wavelength in meters. If no wavelength is provided, the value assumed is 500 nm. The returned Fried parameter has units of meters.\n\n\n\n\n\n","category":"function"},{"location":"parameters/conversions/#Kolmogorov.fried_to_Cn_squared","page":"Parameter Conversions","title":"Kolmogorov.fried_to_Cn_squared","text":"fried_to_Cn_squared(r0::AbstractFloat,\n                    wavelength::AbstractFloat=500e-9)\n\nCalculates the integrated C_n^2 value that yields the provided Fried parameter (r_0). If wavelength is not provided, the value assumed is 500 nm. The returned C_n^2 has units of mathrmm^-23.\n\n\n\n\n\n","category":"function"},{"location":"parameters/conversions/#Kolmogorov.fried_to_seeing","page":"Parameter Conversions","title":"Kolmogorov.fried_to_seeing","text":"fried_to_seeing(r0::AbstractFloat,\n                wavelength::AbstractFloat=500e-9)\n\nCalculates the resulting seeing from a given Fried parameter (r_0) and (optionally) wavelength, both in meters. If no wavelength is provided, the value assumed is 500 nm. The returned seeing is in arcseconds.\n\n\n\n\n\n","category":"function"},{"location":"parameters/conversions/#Kolmogorov.seeing_to_fried","page":"Parameter Conversions","title":"Kolmogorov.seeing_to_fried","text":"seeing_to_fried(seeing::AbstractFloat,\n                wavelength::AbstractFloat=500e-9)\n\nCalculates the Fried parameter (r_0) that yields the provided seeing, seeing must be in arcseconds. If no wavelength is provided, the value assumed is 500 nm. The returned Fried parameter is in units of meters.\n\n\n\n\n\n","category":"function"},{"location":"implementation/types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"implementation/types/","page":"Types","title":"Types","text":"This page is under construction, thank you for your patience.","category":"page"},{"location":"implementation/types/","page":"Types","title":"Types","text":"Atmospheres are implemented as structs, the Atmosphere struct contains a vector of AtmosphericLayers. AtmosphericLayers package together a phase screen with a few extra useful pieces of information that dictate how that screen evolves over time, its altitude above the telescope, and tracks how that screen has evolved thus far.","category":"page"},{"location":"implementation/types/#Constructors","page":"Types","title":"Constructors","text":"","category":"section"},{"location":"implementation/types/","page":"Types","title":"Types","text":"Kolmogorov.AtmosphereicLayer\nKolmogorov.Atmosphere\nKolmogorov.KolmogorovAtmosphere","category":"page"},{"location":"implementation/types/#Kolmogorov.Atmosphere","page":"Types","title":"Kolmogorov.Atmosphere","text":"Atmosphere\n\nThe Atmosphere type which is a type that simply packs together any number of atmospheric layers. Operations which evolve the atmosphere will loop over all the layers within a given atmosphere.\n\n\n\n\n\n","category":"type"},{"location":"implementation/types/#Kolmogorov.KolmogorovAtmosphere","page":"Types","title":"Kolmogorov.KolmogorovAtmosphere","text":"KolmogorovAtmosphere(Cn2::AbstractFloat,\n                     pixelsize::AbstractFloat,\n                     screensize::AbstractFloat,\n                     altitudes::Vector{AbstractFloat},\n                     windvectors::Matrix{AbstractFloat},\n                     layerstrengths::Vector{AbstractFloat},\n                     phasetype::Symbol)\n\nConstructs a full atmosphere where each atmospheric layer has a phase screen with a Kolmogorov power spectrum.\n\nCn2 is the integrated C_n^2 value of the atmosphere, which is internally converted to an r_0 at 500 nanometers.\npixelsize is the size of one pixel in the screen, in meters, and screensize is the total size of the screen in meters.\nscreensize will be adjusted upwards to ensure an integer number of pixels if needed (so the returned screens will always be screensize or larger).\naltitudes is the height in meters of each layer in the atmosphere, and the number of layers is taken as the length of this vector.\nlayerstrengths is the relative strength of each layer, they will be internally normalized, so a vector such as [1, 4] is a valid argument that will yield two layers where one is four times the strength of the other.\nphasetype is a symbol that is :real or :complex that denotes how to store the phase in each layer (:real means the phase itself will be in the arrays, :complex means it will be the Fourier modes of the phase).\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Kolmogorov\nDocTestSetup = :(using Kolmogorov)","category":"page"},{"location":"#Kolmogorov.jl","page":"Home","title":"Kolmogorov.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: GitHub) (Image: Build status) (Image: Coverage)","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This page is a work in progress, apologies","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This page is a work in progress, apologies","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This page is a work in progress, apologies","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The work included here is covered by the MIT License","category":"page"},{"location":"stats/standardones/#Standard-Atmospheric-Statistics","page":"Kolmogorov","title":"Standard Atmospheric Statistics","text":"","category":"section"},{"location":"stats/standardones/","page":"Kolmogorov","title":"Kolmogorov","text":"Here we go through the standard set of atmosphere statistics which are commonly used in adaptive optics simulations.","category":"page"},{"location":"stats/standardones/#Hermitian-Noise","page":"Kolmogorov","title":"Hermitian Noise","text":"","category":"section"},{"location":"stats/standardones/","page":"Kolmogorov","title":"Kolmogorov","text":"The phase screens generated use the approach generating Gaussian Hermitian White Noise, which is then filtered to have a power spectrum matching a particular type. At this point, the inverse FFT is applied to get the phase screen itself. Gaussian Hermitian white noise is generated from the FFT of real white noise, as long as the filter applied to this data is strictly real then the hermitian nature will be preserved and the inverse FFT will still produce strictly real values.","category":"page"},{"location":"stats/standardones/","page":"Kolmogorov","title":"Kolmogorov","text":"Kolmogorov.generate_gaussian_hermitian_noise","category":"page"},{"location":"stats/standardones/#Kolmogorov.generate_gaussian_hermitian_noise","page":"Kolmogorov","title":"Kolmogorov.generate_gaussian_hermitian_noise","text":"generate_gaussian_hermitian_noise(N::int)\n\nGenerates Gaussian hermitian white noise, specifically noise that when you take the inverse FFT the output is strictly real (aside from the imprecision of FFTs). Note that this means it is not a hermitian matrix, because the FFT indexing is different. Returned matrix is NxN and populated with complex numbers.\n\n\n\n\n\n","category":"function"},{"location":"stats/standardones/#Kolmogorov","page":"Kolmogorov","title":"Kolmogorov","text":"","category":"section"},{"location":"stats/standardones/","page":"Kolmogorov","title":"Kolmogorov","text":"This page is under construction, thank you for your patience.","category":"page"},{"location":"stats/standardones/","page":"Kolmogorov","title":"Kolmogorov","text":"Kolmogorov.kolmogorov_psd\nKolmogorob.kolmogorov_filter!","category":"page"},{"location":"stats/standardones/#Kolmogorov.kolmogorov_psd","page":"Kolmogorov","title":"Kolmogorov.kolmogorov_psd","text":"kolmogorov_psd(frequencies::AbstractVector{<:AbstractFloat},\n               Cn_squared::AbstractFloat)\n\nGenerates the 2D Kolmogorov power spectral density (PSD) with a given C_n^2 value which determines the overall strength. The PSD is evaluated on a grid defined by frequencies, which are assumed to be the angular spatial frequencies along one axis of the grid. Specifically, they should be in units of radians/meter. Cn_squared determines the overall normalization of the output PSD. The Kolmogorov PSD is defined as:\n\nPhi_nleft(veckright) = 0033  C_n^2  veck^-113\n\nwhere veck = 2pileft(f_x  hati + f_y  hatjright) is the angular spatial frequency in radians/meter\n\n\n\n\n\n","category":"function"},{"location":"stats/standardones/#von-Karman","page":"Kolmogorov","title":"von Karman","text":"","category":"section"},{"location":"stats/standardones/","page":"Kolmogorov","title":"Kolmogorov","text":"Kolmogorov.vonkarman_psd","category":"page"},{"location":"stats/standardones/#Modified-von-Karman","page":"Kolmogorov","title":"Modified von Karman","text":"","category":"section"},{"location":"stats/standardones/","page":"Kolmogorov","title":"Kolmogorov","text":"Kolmogorov.modified_vonkarman_psd","category":"page"},{"location":"stats/standardones/#Kolmogorov.modified_vonkarman_psd","page":"Kolmogorov","title":"Kolmogorov.modified_vonkarman_psd","text":"modified_vonkarman_psd(frequencies::AbstractVector{<:AbstractFloat},\n                       Cn_squared::AbstractFloat,\n                       L0::AbstractFloat,\n                       l0::AbstractFloat)\n\nGenerates the 2D modified von Karman power spectral density (PSD) with a given C_n^2 value which determines the overall strength, and L_0 which determines the distance at which power rolls off at large distances, and l_0, which determines the power roll off at small distances. The PSD is evaluated on a grid defined by frequencies, which are assumed to be the angular spatial frequencies along one axis of the grid. Specifically, they should be in units of radians/meter. Cn_squared determines the overall normalization of the output PSD. L0 is the outer scale, which is, roughly speaking, the distance after which power no longer increases. The von Karman PSD is defined as:\n\nPhi_nleft(veckright) = frac0033  C_n^2  e^left(k^2k_m^2right)left(veck  +  k_0right)^-113 \n\nwhere veck = 2pileft(f_x  hati + f_y  hatjright) is the angular spatial frequency in radians/meter, k_0 = 2piL_0, and k_m = 592l_0\n\n\n\n\n\n","category":"function"}]
}
